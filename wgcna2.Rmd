---
title: "WGCNA Tutorial II"
author: "Annika Vannan"
date: "4/29/2021"
output:
  rmdformats::downcute:
  code_folding: show
  self-contained: TRUE
  thumbnails: FALSE
  lightbox: TRUE
pkgdown:
  as_is: TRUE
---
  
```{r knitr, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, error = TRUE)
```

# Tutorial II: Consensus Network Analysis of Liver Expression Data, Female and Male Mice

This follows the WGCNA tutorial located on their website. The section names and
numbers reflect those in the original tutorial. Notes are simplified into
Annika-readable formats.

Concepts that were already covered in Tutorial I will be described in less
detail here.

## 0. Load Libraries and Set Environment
```{r setup}
library(WGCNA) # Installed with BiocManager

# Working directory and data loading options
setwd("F:/R Projects/WGCNA Tutorials/")
options(stringsAsFactors = FALSE)
```

## 1. Data Input & Cleaning
### 1.a Loading expression data

Load both male and female data.

```{r load-expr}
femData <- read.csv("FemaleLiver-Data/LiverFemale3600.csv")
maleData <- read.csv("MaleLiver-Data/LiverMale3600.csv")

dim(femData) # 3600 rows (genes), 143 columns
dim(maleData) # 3600 rows, 132 columns
```

Remove columns with supplementary data we don't need, then merge the data into a
multi-set format for consensus analysis. Note that the `exprSize` function
returns useful information about the sizes of all ofthe datasets.

```{r tidy-data}
# We work with two sets
nSets <- 2

# For easier labeling of plots, create a vector holding descriptive names of the two sets.
setLabels <- c("Female liver", "Male liver")
shortLabels <- c("Female", "Male")

# Form multi-set expression data with only the columns we want
multiExpr = vector(mode = "list", length = nSets)
multiExpr[[1]] <- list(data = as.data.frame(t(femData[-c(1:8)])))
multiExpr[[2]] <- list(data = as.data.frame(t(maleData[-c(1:8)])))

# Rename rows and columns to match their contents
names(multiExpr[[1]]$data) <- femData$substanceBXH
rownames(multiExpr[[1]]$data) <- names(femData)[-c(1:8)]
names(multiExpr[[2]]$data) <- maleData$substanceBXH
rownames(multiExpr[[2]]$data) <- names(maleData)[-c(1:8)]

# Check that the data has the correct format for many functions operating on multiple sets:
exprSize <- checkSets(multiExpr)
```

### 1.b Rudimentary Data Cleaning and Outlier Removal

Make sure the genes and samples don't have too many missing values. Use
`goodSamplesGenesMS` and then remove samples/genes if they don't pass the cuts.

```{r outlier-remove}
# Check that all genes and samples have  low numbers of missing values
gsg <- goodSamplesGenesMS(multiExpr, verbose = 3)
gsg$allOK

# Use the following code to remove samples and genes if necessary
if (!gsg$allOK) {
  # Print information about the removed genes:
  if (sum(!gsg$goodGenes) > 0)
    printFlush(paste("Removing genes:", 
                     paste(names(multiExpr[[1]]$data)[!gsg$goodGenes], 
                           collapse = ", ")))
  for (set in 1:exprSize$nSets) {
    if (sum(!gsg$goodSamples[[set]]))
      printFlush(paste("In set", setLabels[set], "removing samples",
                       paste(rownames(
                         multiExpr[[set]]$data)[!gsg$goodSamples[[set]]], 
                         collapse = ", ")))
    # Remove the offending genes and samples
    multiExpr[[set]]$data <- multiExpr[[set]]$data[gsg$goodSamples[[set]], 
                                                   gsg$goodGenes]
    }
  # Update exprSize
  exprSize <- checkSets(multiExpr)
}
```

None of the samples were removed in this case.

Next, cluster samples on their Euclidean distance, separately in each set.

```{r cluster-samples}
# Create an empty list
sampleTrees <- list()

# Fill the list by doing hclust for each dataset
for (set in 1:nSets) {
sampleTrees[[set]] <- hclust(dist(multiExpr[[set]]$data), method = "average")
}
```

To view multiple dendrograms at the same time, you may want to write them all to
a PDF and then view that outside of RStudio. Below we don't do that, but instead
view them both together on one two-panel figure.

Since there is an outlier in the female dataset, we will cut it (height of 15).
The cut line is visualized on the dendrogram below.

```{r dend-cut, fig.cap = "Figure 1: Clustering of samples in the two input sets, female and male liver expression data. The red line in the female dendrogram is the cut line for outlier detection; samples cut by this line are considered outliers. The corresponding cut line for the male samples lies outside of the dendrogram, indicating that no samples from the male set are considered outliers."}
# Choose the "base" cut height for the female data set
baseHeight <- 16

# Adjust the cut height for the male data set for the number of samples
cutHeights <- c(16, 16*exprSize$nSamples[2]/exprSize$nSamples[1])

# Create multiple plots
par(mfrow = c(2,1)); par(mar = c(0, 4, 2, 0))
for (set in 1:nSets) {
  plot(sampleTrees[[set]], 
       main = paste("Sample clustering on all genes in", setLabels[set]), 
       xlab = "", sub = "", cex = 0.7)
  abline(h = cutHeights[set], col = "red")
}
```

Next the outlier is removed:

```{r remove-outlier}
# For loop for removing outliers at the chosen cut height
for (set in 1:nSets) {
  # Find clusters cut by the line
  labels <- cutreeStatic(sampleTrees[[set]], cutHeight = cutHeights[set])
  # Keep the largest one (labeled by the number 1)
  keep <- (labels == 1)
  multiExpr[[set]]$data <- multiExpr[[set]]$data[keep, ]
}
collectGarbage()

# Check the size of the leftover data
exprSize <- checkSets(multiExpr)
exprSize
```

### 1.c Loading Clinical Trait Data

Now we can add the clinical trait data and match the samples for which they were
measured to the expression values.

```{r trait-data}
# Load trait data and get info about the dataset
traitData <- read.csv("FemaleLiver-Data/ClinicalTraits.csv")
dim(traitData) # 361 rows, 38 columns
names(traitData)

# Remove columns that hold information we don't need
allTraits <- traitData[, -c(31, 16)]
allTraits <- allTraits[, c(2, 11:36) ]

# See how big the traits are, along with what are traits and sample names
dim(allTraits) # 361 rows, 27 columns
names(allTraits)
allTraits$Mice

# Form a multi-set structure that will hold the clinical traits
Traits <- vector(mode = "list", length = nSets) # Empty list

for (set in 1:nSets) {
  setSamples <- rownames(multiExpr[[set]]$data)
  traitRows <- match(setSamples, allTraits$Mice)
  Traits[[set]] <- list(data = allTraits[traitRows, -1])
  rownames(Traits[[set]]$data) <- allTraits[traitRows, 1]
}
collectGarbage()

# Define data set dimensions
nGenes <- exprSize$nGenes # 3600 genes
nSamples <- exprSize$nSamples # 134 female and 124 male samples
```

## 2. Network Construction and Module Detection

As with Tutorial I, Tutorial II goes through 3 different methods for network
construction and module detection: 2a) one-step, 2b) step-by-step, and 2c)
block-wise approaches.

### 2.a One-Step Network Construction and Module Detection

One-step construction is the easiest but least customizable option.

#### 2.a.1 Choosing the soft-thresholding power: Analysis of network topology

First we must choose the soft-thresholding power. This uses methods that can be
found in Tutorial I. The user gives a set of candidate powers, and the function
below reutrns a set of network indices that should be inspected.

```{r sft-plots, fig.cap = "Figure 2: Summary network indices (y-axes) as functions of the soft thresholding power (x-axes). Numbers in  the plots indicate the corresponding soft thresholding powers. The plots indicate that approximate scale-free topology is attained around the soft-thresholding power of 6 for both sets. Because the summary connectivity measures decline steeply with increasing soft-thresholding power, it is advantageous to choose the lowest power that satisfies the approximate scale-free topology criterion."}
# Choose a set of soft-thresholding powers
powers <- c(seq(4, 10, by = 1), seq(12, 20, by = 2))

# Initialize a list to hold the results of scale-free analysis
powerTables <- vector(mode = "list", length = nSets)

# Call the network topology analysis function for each set in turn
for (set in 1:nSets) {
  powerTables[[set]] <- list(data = 
                               pickSoftThreshold(multiExpr[[set]]$data,
                                                 powerVector = powers,
                                                 verbose = 2)[[2]])
collectGarbage()
}

# Set colors for plotting
colors <- c("black", "red")

# Will plot these columns of the returned scale free analysis tables
plotCols <- c(2, 5, 6, 7)
colNames <- c("Scale Free Topology Model Fit", "Mean connectivity",
              "Median connectivity", "Max connectivity")

# Get the minima and maxima of the plotted points
ylim <- matrix(NA, nrow = 2, ncol = 4)

for (set in 1:nSets) {
  for (col in 1:length(plotCols)) {
    ylim[1, col] <- min(ylim[1, col], 
                        powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
    ylim[2, col] <- max(ylim[2, col], 
                        powerTables[[set]]$data[, plotCols[col]], na.rm = TRUE)
    }
}

# Plot the quantities in the chosen columns vs. the soft thresholding power
par(mfcol = c(2,2)); par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7

for (col in 1:length(plotCols)) {
  for (set in 1:nSets) {
    if (set == 1) {
      plot(powerTables[[set]]$data[,1], 
           -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
           xlab = "Soft Threshold (power)",  ylab = colNames[col], 
           type="n", ylim = ylim[, col], main = colNames[col])
      addGrid()
    } 
    if (col == 1) {
      text(powerTables[[set]]$data[,1], 
           -sign(powerTables[[set]]$data[,3])*powerTables[[set]]$data[,2],
           labels = powers, cex = cex1,col = colors[set])
      }
    else {
      text(powerTables[[set]]$data[,1], powerTables[[set]]$data[,plotCols[col]],
           labels = powers, cex = cex1, col = colors[set])
      }
    if (col == 1) {
      legend("bottomright", legend = setLabels, col = colors, pch = 20)
      }
    else {
      legend("topright", legend = setLabels, col = colors, pch = 20)
    }
  }
}
```

We will pick 6 for our soft-thresholding power because it is the lowest power
in both datasets where the scale-free topology model fit is sufficiently high.

#### 2.a.2 Network construction and consensus module detection

Throughout the tutorial, sections with this title advise the user to investigate
appropriate block sizes and options for the `blockwiseConsensusModules` function
for their own work.

Below we construct the network. Pay specific attention to the arguments
`deepSplit`, `minModuleSize`, and `mergeCutHeight`.

```{r net-results}
net <- blockwiseConsensusModules(multiExpr, power = 6, minModuleSize = 30, 
                                 deepSplit = 2, pamRespectsDendro = FALSE,
                                 mergeCutHeight = 0.25, numericLabels = TRUE,
                                 minKMEtoStay = 0, saveTOMs = TRUE, verbose = 5)
```
The network has been constructed, and we can now visualize the modules and their
colors. This is a consensus dendrogram that plots both the males and females.

Although each gene is part of a single consensus module, each dataset 
(males vs. females) has its own eigengenes for the consensus modules.

In other words, Gene A might be part of the blue consensus module formed from
both male and female data, but the blue module has a different eigengene
(primary Principle Component) for males vs. females.

More detail on this concept is found in section 4.

```{r consensus-dend1, fig.cap = "Figure 2: Gene dendrogram obtained by clustering the dissimilarity based on consensus Topological Overlap with the corresponding module colors indicated by the color row."}
# Get the consensus module eigengenes and the module colors
consMEs <- net$multiMEs
moduleLabels <- net$colors

# Convert the numeric labels to color labels
moduleColors <- labels2colors(moduleLabels)
consTree <- net$dendrograms[[1]]

# Plot
plotDendroAndColors(consTree, moduleColors, "Module colors", 
                    dendroLabels = FALSE, hang = 0.03, addGuide = TRUE,
                    guideHang = 0.05, 
                    main = "Consensus gene dendrogram and module colors")
```

### 2.b Step-by-Step Network Construction and Module Detection

The step-by-step approach is more customizable than the one-step approach.

#### 2.b.1 Choosing the soft-thresholding power: Analysis of network topology

This section is the same as 2.a.1.

#### 2.b.2 Calculation of network adjacencies

First the network adjacencies will be calculated for each individual set with
the soft-thresholding power of 6.

```{r adj}
# Set power
softPower <- 6

# Initialize an appropriate array to hold the adjacencies
adjacencies <- array(0, dim = c(nSets, nGenes, nGenes))

# Calculate adjacencies in each individual data set
for (set in 1:nSets) {
  adjacencies[set, , ] <- abs(cor(multiExpr[[set]]$data, use = "p"))^softPower
}
```

#### 2.b.3 Calculation of topological overlap

The adjacencies can then be created into a Topological Overlap Matrix (TOM).

```{r tom}
# Initialize an appropriate array to hold the TOMs
TOM <- array(0, dim = c(nSets, nGenes, nGenes))

# Calculate TOMs in each individual data set
for (set in 1:nSets) {
  TOM[set, , ] <- TOMsimilarity(adjacencies[set, , ])
}
```

#### 2.b.4 Scaling of TOMs to make them comparable across sets

TOMs for different datasets may have different statistical properties, so they
need to be scaled in order to compare them. Here, they are scaled so that the 
95th percentile of the male TOM equals the 95% of the female TOM. This is done
through random sampling.

```{r scale-toms}
# Define the reference percentile
scaleP <- 0.95

# Set RNG seed for reproducibility of sampling
set.seed(12345)

# Sample sufficiently large number of TOM entries
nSamples <- as.integer(1/(1-scaleP)*1000)

# Choose the sampled TOM entries
scaleSample <- sample(nGenes*(nGenes-1)/2, size = nSamples)
TOMScalingSamples <- list()

# These are TOM values at reference percentile
scaleQuant <- rep(1, nSets)

# Scaling powers to equalize reference TOM values
scalePowers <- rep(1, nSets)

# Loop over sets
for (set in 1:nSets) {
  # Select the sampled TOM entries
  TOMScalingSamples[[set]] <- as.dist(TOM[set, , ])[scaleSample]
  # Calculate the 95th percentile
  scaleQuant[set] <- quantile(TOMScalingSamples[[set]], 
                              probs = scaleP, type = 8)
  # Scale the male TOM
  if (set>1) {
    scalePowers[set] <- log(scaleQuant[1])/log(scaleQuant[set])
    TOM[set, ,] <- TOM[set, ,]^scalePowers[set]
    }
}

```

The array TOM now contains the scaled TOMs. To view the result of scaling, we
can make a quantile-quantile plot of the topological overlaps before and after
scaling.

```{r tom-plots, fig.cap = "Figure 3: Quantile-quantile plot of the TOMs in male and female data sets. The black points are TOMs before scaling, the red points are TOMs after scaling. The closer the points lie to the reference line shown in blues, the closer is the distribution of the TOM values in the two data sets."}
# For plotting, also scale the sampled TOM entries
scaledTOMSamples <- list()
for (set in 1:nSets) {
  scaledTOMSamples[[set]] <- TOMScalingSamples[[set]]^scalePowers[set]
}

# QQ plot of the unscaled samples
qqUnscaled <- qqplot(TOMScalingSamples[[1]], TOMScalingSamples[[2]], 
                     plot.it = TRUE, cex = 0.6, 
                     xlab = paste("TOM in", setLabels[1]), 
                     ylab = paste("TOM in", setLabels[2]), 
                     main = "Q-Q plot of TOM", pch = 20)

# QQ plot of the scaled samples
qqScaled <- qqplot(scaledTOMSamples[[1]], scaledTOMSamples[[2]], 
                   plot.it = FALSE)
points(qqScaled$x, qqScaled$y, col = "red", cex = 0.6, pch = 20)
abline(a = 0, b = 1, col = "blue")
legend("topleft", legend = c("Unscaled TOM", "Scaled TOM"), 
       pch = 20, col = c("black", "red"))

```

The scaling changed the male TOM slightly and brought it closer to the reference
line in blue.

#### 2.b.5 Calculation of consensus topological overlap

The consensus TOM can be calculated by taking the component-wise ("parallel")
minimum of the TOMs in the individual sets.

```{r, consensus-tom}
consensusTOM <- pmin(TOM[1, , ], TOM[2, , ])
```

#### 2.b.6 Clustering and module identification

The consensus TOM is then used for hierarchical clustering. We can use the
`cutreeDynamic` function to help us identify modules. See Tutorial I for more
information on module identification. Below is the consensus dendrogram, along
with a table of the consensus modules and number of genes.

Here, the results are the same between the present analysis and the tutorial.

```{r consensus-dend2, "Figure 4: Gene dendrogram obtained by clustering based on the consensus topological overlap across male andfemale mice. The identified preliminary modules are indicated in the color row beneath the dendrogram."}
# Clustering
consTree <- hclust(as.dist(1-consensusTOM), method = "average")

# We like large modules, so we set the minimum module size relatively high
minModuleSize <- 30

# Module identification using Dynamic Tree Cut
unmergedLabels <- cutreeDynamic(dendro = consTree, distM = 1-consensusTOM,
                                deepSplit = 2, cutHeight = 0.995, 
                                minClusterSize = minModuleSize,
                                pamRespectsDendro = FALSE)
unmergedColors <- labels2colors(unmergedLabels)

# Module summaries
table(unmergedLabels)

# Plot
plotDendroAndColors(consTree, unmergedColors, "Dynamic Tree Cut", 
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)

```

#### 2.b.7 Merging of modules whose expression profiles are very similar

Modules that are highly correlated can often be merged. In this example, we will
merge modules that fall below the branch height of 0.25. As with Tutorial I,
this corresponds to a correlation between modules of 0.75 or higher.

Below, we plot the modules before merging:

```{r merge-mod-dend, fig.cap = "Figure 5: Gene dendrogram obtained by clustering based on the consensus topological overlap across male and female mice. The identified preliminary modules are indicated in the color row beneath the dendrogram."}
# Calculate module eigengenes
unmergedMEs <- multiSetMEs(multiExpr, colors = NULL, 
                           universalColors = unmergedColors)

# Calculate consensus dissimilarity of consensus module eigengenes
consMEDiss <- consensusMEDissimilarity(unmergedMEs)

# Cluster consensus modules
consMETree <- hclust(as.dist(consMEDiss), method = "average")

# Plot
par(mfrow = c(1, 1))
plot(consMETree, main = "Consensus clustering of consensus module eigengenes",
     xlab = "", sub = "")
abline(h = 0.25, col = "red")
```

Two pairs of modules, cyan + greenyellow and purple + yellow, fall below the cut
line and will be merged together. Then we will plot a new cluster dendrogram of
the genes that also shows the modules before and after merging.

*NOTE: The results of the merging do NOT match the tutorial results. As with
Tutorial I, we're going to chalk this up to differences between the versions of
R and WGCNA. However, they are very similar. Note that unlike the tutorial,
the unmerged modules are shown on top of the merged modules.*

```{r merge-mod-gene-dend, fig.cap = "Figure 6: Gene dendrogram obtained by clustering the dissimilarity based on consensus Topological Overlap. The two color rows show the preliminary (unmerged) and the final, merged module assignments."}
# Merge the similary modules
merge <- mergeCloseModules(multiExpr, unmergedLabels, 
                           cutHeight = 0.25, verbose = 3)

# Numeric module labels
moduleLabels <- merge$colors

# Convert labels to colors
moduleColors <- labels2colors(moduleLabels)

# Eigengenes of the new merged modules
consMEs <- merge$newMEs

# Plot
plotDendroAndColors(consTree, cbind(unmergedColors, moduleColors), 
                    c("Unmerged", "Merged"), dendroLabels = FALSE, hang = 0.03, 
                    addGuide = TRUE, guideHang = 0.05)

```
### 2.c Automatic Block-Wise Network Construction and Consensus Module Detection

This is an indirect approach to analyzing large datasets by getting block-wise
results and then merging them. This method is similar to the one-step approach
in its results, but is not recommended.

#### 2.c.1 Choosing the soft-thresholding power: Analysis of network topology

This section is the same as 2.a.1 and 2.b.1.

#### 2.c.2 Block-wise network construction and consensus module detection

Below, the 3600 genes are divided into blocks with a max size of 2000 genes.
For more information on block-wise network construction and the chosen 
parameters, see Tutorial I.

```{r bwnet}
cor <- WGCNA::cor

bwnet <- blockwiseConsensusModules(multiExpr, maxBlockSize = 2000, power = 6, 
                                   minModuleSize = 30, deepSplit = 2,
                                   pamRespectsDendro = FALSE, 
                                   mergeCutHeight = 0.25, numericLabels = TRUE,
                                   minKMEtoStay = 0, saveTOMs = TRUE, 
                                   verbose = 5)
```

The tutorial states that the block-wise and one-step modules should produce
similar results. To show this, we will compare the results of the two analyses.

First, we need to relabel the block-wise modules so that those with significant
overlap with the one-step approach have the same color names. E.g. if the brown
block-wise module is highly similar to the blue one-step module, the brown
block-wise module will be renamed as "blue." A Fisher's exact test is performed
to determine whether modules have significant overlap. In the below example, we
use a p-value threshold of 1e-7 to determine similarity of modules.

Then we can view the results of the block-wise analysis.

*NOTE: Because the consensus results from 2.b don't match the tutorial, the
table output here will also not match the tutorial.*

```{r compare-modules}
# Relabel bw modules
bwLabels <- matchLabels(bwnet$colors, moduleLabels, pThreshold = 1e-7)
bwColors <- labels2colors(bwLabels)

# View results
table(bwLabels)
```
Next, we'll plot the gene dendrograms and module color assignments for each
block separately. Again the results are different from the tutorial.

```{r blocks-dend, fig.cap = "Figure 7: Gene dendrograms obtained by block-wise clustering the dissimilarity based on consensus Topological Overlap with the corresponding module colors indicated by the color row."}
# The layout function will be used to pretty-ify the figure
layout(matrix(c(1:4), 2, 2), heights = c(0.8, 0.2), widths = c(1, 1))

# Set the number of blocks
nBlocks <- length(bwnet$dendrograms)

# Plot the dendrogram and the module colors underneath for each block
for (block in 1:nBlocks) {
  plotDendroAndColors(bwnet$dendrograms[[block]], 
                      moduleColors[bwnet$blockGenes[[block]]], "Module colors",
                      main = paste("Gene dendrogram and module colors in block", 
                                   block),
                      dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, 
                      guideHang = 0.05, setLayout = FALSE)
}
```
The results appear to the same as the tutorial (or at least very similar), 
except the modules have different color labels.

#### 2.c.3 Comparing block-wise and standard modules

Now we can finally compare the block-wise results to the one-step results using
a plot.

*NOTE: Although this figure does demonstrate a clear relationship between the
two analyses, the module color labels still do not match the tutorial. For 
example, the pink and green modules below correspond to yellow and and turquoise
in the tutorial.*

```{r compare-approach-dend, "fig.cap = Figure 8: Gene dendrogram obtained in the single-block analysis together with the corresponding single-block module colors and the module colors obtained by block-wise clustering. The plot indicates a strong correspondence between the standard and the block-wise modules."}
# Plot
plotDendroAndColors(consTree, cbind(moduleColors, bwColors), 
                    c("Single block", "Blockwise"), dendroLabels = FALSE, 
                    hang = 0.03, addGuide = TRUE, guideHang = 0.05, 
                    main = "Single block consensus gene dendrogram and module colors")
```

Using the modified code, we can see the results are similar between the two
approaches.

## 3. Relating Consensus Modules to Female Set-Specific Modules

Now we will compare the consensus analysis, which used both males and females,
to the female-only analysis from Tutorial I. First, we need to load the female
results. The tutorial has us rename the variables here, but since we chose to
rename them while doing Tutorial I, that's not necessary.

First we need to load the results from Tutorial I.

The following objects will be loaded (old name in paretheses):

* femaleMEs (MEs) 
* femaleLabels (moduleLabels)
* femaleColors (moduleColors)
* femaleTree (geneTree)

```{r load-tutorial1-fem}
# Load data
lnames <- load("FemaleLiver-02-networkConstruction-auto.RData")
lnames
```

The consensus network analysis results don't need to be loaded because we
created them here. The variables we need are:

* consMEs
* moduleLabels
* moduleColors
* consTree

Now that we have all the data we need, we'll calculate the overlaps between each
pair of female-consensus modules. The Fisher's exact test will be used to assign
a p-value to each pairwise overlap.

The order of the module labels is determined by how similar the eigenvectors are
to each other.

**QUESTION: Is it possible to modify this code to use `overlapTable` instead?**
That command requires the same number of modules for each comparison, but I
suppose you could theoretically just remove the modules you aren't interested
in. It seems like it produces the same sort of thing - a list with 2 components,
`countTable` and `pTable`.

```{r compare-consensus-fem}
# Isolate module labels in the order they appear in ordered module eigengenes
femModuleLabels <- substring(names(femaleMEs), 3)
consModuleLabels <- substring(names(consMEs[[1]]$data), 3)

# Convert the numeric module labels to color labels
femModules <- labels2colors(as.numeric(femModuleLabels))
consModules <- labels2colors(as.numeric(consModuleLabels))

# Numbers of female and consensus modules
nFemMods <- length(femModules)
nConsMods <- length(consModules)

# Initialize tables of p-values and of the corresponding counts
pTable <- matrix(0, nrow = nFemMods, ncol = nConsMods)
CountTbl <- matrix(0, nrow = nFemMods, ncol = nConsMods)

# Execute all pairwise comparisons
for (fmod in 1:nFemMods) {
  for (cmod in 1:nConsMods) {
    femMembers <- (femaleColors == femModules[fmod])
    consMembers <- (moduleColors == consModules[cmod])
    pTable[fmod, cmod] <- -log10(fisher.test(femMembers, consMembers, 
                                             alternative = "greater")$p.value)
    CountTbl[fmod, cmod] <- sum(femaleColors == femModules[fmod] & 
                                  moduleColors == consModules[cmod])
  }
}
```

In order to display the count and p-value tables in an informative way, we can
create a color-coded table of the intersection counts. The colors will indicate
p-value significance.

```{r compare-heatmap, fig.cap = "Figure 9: Correspondence of female set-specific modules and the female-male consensus modules. Each row of the table corresponds to one female set-specific module (labeled by color as well as text), and each column corresponds to one consensus module. Numbers in the table indicate gene counts in the intersection of the corresponding modules. Coloring of the table encodes − log(p), with p being the Fisher’s exact test p-value for the overlap of the two modules. The stronger the red color, the more significant the overlap is. The table indicates that most female set-specific modules have a consensus counterpart."}
# Truncate p values smaller than 10^{-50} to 10^{-50}
pTable[is.infinite(pTable)] <- 1.3*max(pTable[is.finite(pTable)])
pTable[pTable > 50 ] <- 50

# Marginal counts (really module sizes)
femModTotals <- apply(CountTbl, 1, sum)
consModTotals <- apply(CountTbl, 2, sum)

# Plot
par(mfrow = c(1, 1)); par(cex = 1.0); par(mar = c(8, 10.4, 2.7, 1) + 0.3)
# Use `labeledHeatmap` to produce the color-coded table with all the trimmings
labeledHeatmap(Matrix = pTable, xLabels = paste(" ", consModules), 
               yLabels = paste(" ", femModules), colorLabels = TRUE, 
               xSymbols = paste("Cons ", consModules, ": ", 
                                consModTotals, sep=""), 
               ySymbols = paste("Fem ", femModules, ": ", femModTotals, sep=""),
               textMatrix = CountTbl, colors = greenWhiteRed(100)[50:100], 
               main = "Correspondence of Female set-specific and 
               Female-Male consensus modules", cex.text = 1.0, cex.lab = 1.0, 
               setStdMargins = FALSE)
```

The result here is not exactly the same as the tutorial, but it's very similar.

The columns are the consensus modules, and the rows are the female-specific
modules. The values in the matrix indicate the number of genes that are shared
between the two modules.

The highest overlap between modules is female brown to consensus yellow (fem 
brown to cons turquoise in the tutorial) with 339 shared genes.

Two female modules (grey60 and lightgreen in the tutorial) that have no
counterpart module in the consensus analysis.

Interestingly, there are two female modules, grey60 and lightgreen (same in the
tutorial) that have no consensus counterpart. Almost all of the genes in these
two modules are assigned to the grey consensus module. Remember that the grey
(NOT grey60) modules consist of genes that were unassigned to an actual module
in the analysis.

## 4. Relating Consensus Modules to External Microarray Sample Information and Exporting Network Analysis Results

Now we will relate clinical traits to the consensus module eigengenes in each of
the two sets. Recall that the mdoule eigengenes are the 1st Principle Components
in each module. Also, while the consensus modules have a single module
assignment for all genes, the module eigengenes represent the modules for each
set separately.

Copying and pasting my words from earlier in this Rmd:

*Although each gene is part of a single consensus module, each dataset (males 
vs. females) has its own eigengenes for the consensus modules.

In other words, Gene A might be part of the blue consensus module formed from
both male and female data, but the blue module has a different eigengene
(primary Principle Component) for males vs. females.*

We also have trait data separately for males and females.

First, we'll calculate the overall correlations between each trait and module,
separately for males and females.

```{r module-trait}
# Set up variables to contain the module-trait correlations
moduleTraitCor <- list()
moduleTraitPvalue <- list()

# Calculate the correlations
for (set in 1:nSets) {
moduleTraitCor[[set]] <- cor(consMEs[[set]]$data, 
                             Traits[[set]]$data, use = "p")
moduleTraitPvalue[[set]] <- corPvalueFisher(moduleTraitCor[[set]], 
                                            exprSize$nSamples[set])
}
```

Then we can display the values in a color-coded table. The colors indicate
p-value significance.

Females:

```{r fem-mod-trait-heat, fig.cap = "Figure 10: Relationships of consensus module eigengenes and clinical traits in the female data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend."}
# Convert numerical lables to colors for labeling of modules in the plot
MEColors <- labels2colors(as.numeric(substring(names(consMEs[[1]]$data), 3)))
MEColorNames <- paste("ME", MEColors, sep = "")

# Plot the module-trait relationship table for set number 1 (Females)
set <- 1
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(", 
                    signif(moduleTraitPvalue[[set]], 1), ")", sep = "")

dim(textMatrix) <- dim(moduleTraitCor[[set]])

par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(Matrix = moduleTraitCor[[set]], 
               xLabels = names(Traits[[set]]$data), yLabels = MEColorNames,
               ySymbols = MEColorNames, colorLabels = FALSE, 
               colors = greenWhiteRed(50), textMatrix = textMatrix, 
               setStdMargins = FALSE, cex.text = 0.5, zlim = c(-1, 1),
               main = paste("Module--trait relationships in", setLabels[set]))
```

Males:

```{r male-mod-trait-hear, fig.cap = "Figure 11: Relationships of consensus module eigengenes and clinical traits in the male data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend."}
# Plot the module-trait relationship table for set number 2 (Males)
set <- 2
textMatrix <- paste(signif(moduleTraitCor[[set]], 2), "\n(", 
                    signif(moduleTraitPvalue[[set]], 1), ")", sep = "")

dim(textMatrix) <- dim(moduleTraitCor[[set]])

par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(Matrix = moduleTraitCor[[set]], 
               xLabels = names(Traits[[set]]$data), yLabels = MEColorNames, 
               ySymbols = MEColorNames, colorLabels = FALSE, 
               colors = greenWhiteRed(50), textMatrix = textMatrix, 
               setStdMargins = FALSE, cex.text = 0.5, zlim = c(-1, 1), 
               main = paste("Module--trait relationships in", setLabels[set]))
```

The male and female module-trait relationships show that the turquoise, purple,
and green modules are all highly related to weight, though the correlations and
p-values differ between males and females.

We also want to view the relationship between module-trait pairs for both sets
overall. There are several ways to do this, but the tutorial chooses a
conservative approach. Here, we will take the correlation that has the *lower*
absolute value in the two sets **if both correlations have the same sign**, and
a zero relationship (no correlation) if both sets have correlations with
opposite signs.

We will first create matrices with the consensus correlations and p-values.

```{r consensus-corr}
# Initialize matrices to hold the consensus correlation and p-value
consensusCor <- matrix(NA, nrow(moduleTraitCor[[1]]), 
                       ncol(moduleTraitCor[[1]]))
consensusPvalue <- matrix(NA, nrow(moduleTraitCor[[1]]),
                          ncol(moduleTraitCor[[1]]))

# Find consensus negative correlations
negative <- moduleTraitCor[[1]] < 0 & moduleTraitCor[[2]] < 0

consensusCor[negative] <- pmax(moduleTraitCor[[1]][negative], 
                               moduleTraitCor[[2]][negative])
consensusPvalue[negative] <- pmax(moduleTraitPvalue[[1]][negative], 
                                  moduleTraitPvalue[[2]][negative])

# Find consensus positive correlations
positive = moduleTraitCor[[1]] > 0 & moduleTraitCor[[2]] > 0

consensusCor[positive] <- pmin(moduleTraitCor[[1]][positive], 
                               moduleTraitCor[[2]][positive])
consensusPvalue[positive] <- pmax(moduleTraitPvalue[[1]][positive], 
                                  moduleTraitPvalue[[2]][positive])
```

Next we will view the results in a heatmap.

```{r consensus-mod-trait-heat, fig.cap = Figure 12: Consensus relationships of consensus module eigengenes and clinical traits across the female and male data. Each row in the table corresponds to a consensus module, and each column to a trait. Numbers in the table report the consensus correlations of the corresponding module eigengenes and traits, with the p-values printed below the correlations in parentheses. The table is color coded by correlation according to the color legend. Missing (NA) entries indicate that the correlations in the male and female data sets have opposite signs and no consensus can be formed.}
textMatrix <- paste(signif(consensusCor, 2), "\n(", 
                    signif(consensusPvalue, 1), ")", sep = "")

dim(textMatrix) <- dim(moduleTraitCor[[set]])

# Plot
par(mar = c(6, 8.8, 3, 2.2))
labeledHeatmap(Matrix = consensusCor, xLabels = names(Traits[[set]]$data),
               yLabels = MEColorNames, ySymbols = MEColorNames, 
               colorLabels = FALSE, colors = greenWhiteRed(50), 
               textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.5, 
               zlim = c(-1, 1), 
               main = paste("Consensus module--trait relationships across\n", 
                            paste(setLabels, collapse = " and ")))

```

### 4.a Exporting Results of the Network Analysis

Now we will put together a dataframe that summarizes the results of the network 
analyses. It will contain the gene significances (GS) and module memberships
(kME) of all genes.

After loading the gene annotation table, we'll re-calculate the module 
eigengenes in alphabetic order and then calculate the GS and kME values for each
dataset.

```{r annot-recalc}
annot <- read.csv(file = "FemaleLiver-Data/GeneAnnotation.csv")

# Match probes in the data set to the probe IDs in the annotation file
probes <- names(multiExpr[[1]]$data)
probes2annot <- match(probes, annot$substanceBXH)

consMEs.unord <- multiSetMEs(multiExpr, universalColors = moduleLabels, 
                             excludeGrey = TRUE)

# Create empty lists
GS <- list()
kME <- list()

for (set in 1:nSets) {
  GS[[set]] <- corAndPvalue(multiExpr[[set]]$data, Traits[[set]]$data)
  kME[[set]] <- corAndPvalue(multiExpr[[set]]$data, consMEs.unord[[set]]$data)
}
```

We can perform a very simple "meta-analysis" by combining the Z scores of 
correlations from each set to form a meta-Z score and the corresponding p-value.

```{r meta-z}
GS.metaZ <- (GS[[1]]$Z + GS[[2]]$Z)/sqrt(2)
kME.metaZ <- (kME[[1]]$Z + kME[[2]]$Z)/sqrt(2)
GS.metaP <- 2*pnorm(abs(GS.metaZ), lower.tail = FALSE)
kME.metaP <- 2*pnorm(abs(kME.metaZ), lower.tail = FALSE)
```

Then we make matricies that hold the GS and kME. We'll reformat the data so that
the GS, kME, p-values, and meta-anaylsis results are all next to each other.

```{r, gs-kme-data}
# GS:
GSmat <- rbind(GS[[1]]$cor, GS[[2]]$cor, GS[[1]]$p, GS[[2]]$p, 
               GS.metaZ, GS.metaP)
nTraits <- checkSets(Traits)$nGenes
traitNames <- colnames(Traits[[1]]$data)
dim(GSmat) <- c(nGenes, 6*nTraits)
rownames(GSmat) <- probes
colnames(GSmat) <- spaste(c("GS.set1.", "GS.set2.", "p.GS.set1.", "p.GS.set2.", 
                            "Z.GS.meta.", "p.GS.meta"), 
                          rep(traitNames, rep(6, nTraits)))

# Same code for kME:
kMEmat <- rbind(kME[[1]]$cor, kME[[2]]$cor, kME[[1]]$p, kME[[2]]$p, 
                kME.metaZ, kME.metaP)
MEnames <- colnames(consMEs.unord[[1]]$data)
nMEs <- checkSets(consMEs.unord)$nGenes
dim(kMEmat) <- c(nGenes, 6*nMEs)
rownames(kMEmat) <- probes
colnames(kMEmat) <- spaste(c("kME.set1.", "kME.set2.", "p.kME.set1.", 
                             "p.kME.set2.", "Z.kME.meta.", "p.kME.meta"), 
                           rep(MEnames, rep(6, nMEs)))
```

Lastly, we put all the data into a dataframe and write it to a CSV file. The
genes aren't sorted here, but could be sorted depending on how you want the file
to look.

When reading this file, remember that set 1 = Females, and set 2 = Males.

```{r full-data}
# Create complete dataframe
info <- data.frame(Probe = probes, GeneSymbol = annot$gene_symbol[probes2annot],
                   EntrezID = annot$LocusLinkID[probes2annot], 
                   ModuleLabel = moduleLabels, 
                   ModuleColor = labels2colors(moduleLabels), GSmat, kMEmat)

# Write file
write.csv(info, file = "consensusAnalysis-CombinedNetworkResults.csv", 
          row.names = FALSE, quote = FALSE)
```

## 5. Comparing Eigengene Networks in Male and Female Mice

Finally we're at the end! We're going to compare the consensus networks in the
male and female datasets. This is the "differential analysis" step.

Consensus eigengene networks capture the relationships among consensus modules.
The relationships are quantified by eigengene correlations. We can add the trait
"weight" as an additional "eigengene":

```{r differential-analysis}
# Create a variable `weight` for just the body weight of mice in both sets
weight <- vector(mode = "list", length = nSets)
for (set in 1:nSets) {
  weight[[set]] <- list(data = as.data.frame(Traits[[set]]$data$weight_g))
  names(weight[[set]]$data) <- "weight"
}

# Recalculate consMEs to give them color names
consMEsC <- multiSetMEs(multiExpr, universalColors = moduleColors)

# Add weightto the eigengenes and order by consesus hierarchical clustering
MET <- consensusOrderMEs(addTraitToMEs(consMEsC, weight))
```
Now to get those beautiful final plots:

```{r differential-plots, fig.width = 9, fig.height = 10, fig.cap = "Figure 13: Summary plot of consensus eigengene networks and their differential analysis. The top two panels show the dendrograms (clustering trees) of the consensus module eigengenes in the two sets indicated in the titles. Below, the eigengene networks in the two sets are shown as heatmaps labeled Female liver and Male liver. In the heatmaps, red denotes high adjacency (positive correlation) and green denotes low adjacency (negative correlation). The Preservation heatmap shows the preservation network, defined as one minus the absolute difference of the eigengene networks in the two data sets. The barplot shows the mean preservation of adjacency for each of the eigengenes to all other eigengenes; in other words, the barplot depicts the column means of the preservation heatmap."}
# Plot
par(cex = 0.9)
plotEigengeneNetworks(MET, setLabels, marDendro = c(0, 2, 2, 1), 
                      marHeatmap = c(3, 3, 2, 1), zlimPreservation = c(0.5, 1), 
                      xLabelsAngle = 90)
```

The plot shows:

* Eigengene dendrograms for each set
* Eigengene network heatmaps for each set
* Network preservation between the two sets (heatmap)
* Mean preservation of relationships for each eigengene (barplot)

The overall preservation of the two eigengene networks is quite high (0.94). 
Visually, the heatmap also shows that the inter-module relationships between the
two sets are very similar. 

On the network heatmaps, the red blocks along the diagonal indicate
meta-modules. These are the groups of highly correlated eigengenes. For example,
there is a set of 4 modules - black, pink, lightcyan, and salmon - that are
highly correlated for females as evidenced by both the dendrogram and the 
heatmap. These modules are also highly correlated for males!

Inter-module relationships are strongly preserved across similar data sets and
encode biologically meaningful information.












